# 20251114

### **Conclusion**

**DataView** is now conceptualised as a **thin, ephemeral object** similar to `NET’s SqlCommand`:

* Holds a **query** definition and the **results** of that query as a developer-friendly cache.
* Can be **registered** with **DataLens** for orchestration, allowing automatic query refresh and update commit on a configurable tick frequency.
* Registered DataViews support an optional **priority**, letting DataLens determine the “winner” when batching updates; otherwise, operations are applied FIFO.
* Non-registered DataViews or manual Query/Update/Commit operations are handled in a **locking model**, buffering requests while sensitive operations are running.
* DataLens is responsible for executing all queries and commits using **raw, high-performance operations**, ensuring thread safety and collision avoidance.
* All operations support a **callback model**, notifying the game code when the requested action is complete; the game can decide to block or poll for completion.

This design shifts DataView from being a memory-owning buffer to a **transactional, dev-facing interface** that wraps DataLens functionality in a convenient, flexible form.

***

### **Detailed Notes and Thought Process**

#### 1. DataView Purpose

* Acts as a **developer-friendly cache and transaction object**.
* Contains the query results and staged updates.
* Provides optional orchestration through **registration** with DataLens.
* Does **not own memory directly**; DataLens manages all underlying buffers and operations.

#### 2. Registered vs Non-Registered Views

* **Registered DataViews**:
  * Committed and refreshed automatically by DataLens each tick.
  * Parallel operations are possible across DataStores because DataLens manages thread safety.
  * Supports optional **priority** for deterministic batching of updates.
* **Non-registered / manual DataViews**:
  * Operations are **locking**: requests are buffered while DataLens runs sensitive processes.
  * The callback mechanism informs the caller when the operation is complete.

#### 3. Query and Update Model

* **Query**: returns a row-major collection of the requested DataStore subset.
* **Update**: queued through the DataView, applied by DataLens on commit.
* **Commit**: can be global (`CommitAll()`) or per-store (`Commit(Store)`), batching updates efficiently.
* Registered views ensure **select operations run after updates** on the same tick, avoiding race conditions.

#### 4. Transaction and Cache Behaviour

* Updates in a DataView are **transactional**: staged until commit.
* Queries operate on the cached results of the last refresh.
* No overlap restrictions are enforced; DataLens ensures thread safety and determinism during execution.

#### 5. Callback Mechanism

* All DataView operations expose **callbacks** for completion.
* The game code can choose to:
  * Wait/block until completion, or
  * Continue execution and check back asynchronously.

#### 6. Analogy

* Registered DataViews are like **auto-refreshing, transactional SqlCommand objects** with optional prioritisation.
* Non-registered DataViews are like **manual SqlCommand objects** executed on demand, subject to DataLens scheduling.

***

### **Next Steps**

* Define **C++ and C# APIs** for DataView, including registration, query, update, commit, and callback support.
* Specify **priority and tick frequency** metadata for orchestrated DataViews.
* Implement **thread-safe batch execution** in DataLens for registered views.
